fn @putint(#x: i32) -> ();

fn @putch(#x: i32) -> ();

fn @putarray(#n: i32, #arr: i32*) -> ();

fn @getint() -> i32;

fn @getch() -> i32;

fn @getarray(#n: i32, #arr: i32*) -> ();

fn @main() -> i32 {
%entry:
  let %ret_val.addr: i32* = alloca i32, 1
  let %a: i32* = alloca i32, 1
  let %b: i32* = alloca i32, 1
  let %c: i32* = alloca i32, 1
  let %d: i32* = alloca i32, 1
  let %result: i32* = alloca i32, 1
  let %8: () = store 5, %a: i32*
  let %9: () = store 5, %b: i32*
  let %10: () = store 1, %c: i32*
  let %11: i32 = sub 0, 2
  let %12: () = store %11: i32, %d: i32*
  let %13: () = store 2, %result: i32*
  let %14: i32 = load %d: i32*
  let %15: i32 = mul %14: i32, 1
  let %16: i32 = div %15: i32, 2
  let %17: i32 = lt %16: i32, 0
  let %short_val.addr: i32* = alloca i32, 1
  let %19: () = store %17: i32, %short_val.addr: i32*
  br %17: i32, label %short.end, label %short.rhs
%short.rhs:
  let %22: i32 = load %a: i32*
  let %23: i32 = load %b: i32*
  let %24: i32 = sub %22: i32, %23: i32
  let %25: i32 = ne %24: i32, 0
  let %short_val.addr.1: i32* = alloca i32, 1
  let %27: () = store %25: i32, %short_val.addr.1: i32*
  br %25: i32, label %short.rhs.1, label %short.end.1
%short.end:
  let %37: i32 = load %short_val.addr: i32*
  br %37: i32, label %if_then, label %if_end
%short.rhs.1:
  let %30: i32 = load %c: i32*
  let %31: i32 = add %30: i32, 3
  let %32: i32 = rem %31: i32, 2
  let %33: i32 = ne %32: i32, 0
  let %34: () = store %33: i32, %short_val.addr.1: i32*
  jmp label %short.end.1
%short.end.1:
  let %35: i32 = load %short_val.addr.1: i32*
  let %36: () = store %35: i32, %short_val.addr: i32*
  jmp label %short.end
%if_then:
  let %40: i32 = load %result: i32*
  let %41: () = call @putint, %40: i32
  jmp label %if_end
%if_end:
  let %42: i32 = load %d: i32*
  let %43: i32 = rem %42: i32, 2
  let %44: i32 = add %43: i32, 67
  let %45: i32 = lt %44: i32, 0
  let %short_val.addr.2: i32* = alloca i32, 1
  let %47: () = store %45: i32, %short_val.addr.2: i32*
  br %45: i32, label %short.end.2, label %short.rhs.2
%short.rhs.2:
  let %50: i32 = load %a: i32*
  let %51: i32 = load %b: i32*
  let %52: i32 = sub %50: i32, %51: i32
  let %53: i32 = ne %52: i32, 0
  let %short_val.addr.3: i32* = alloca i32, 1
  let %55: () = store %53: i32, %short_val.addr.3: i32*
  br %53: i32, label %short.rhs.3, label %short.end.3
%short.end.2:
  let %65: i32 = load %short_val.addr.2: i32*
  br %65: i32, label %if_then.1, label %if_end.1
%short.rhs.3:
  let %58: i32 = load %c: i32*
  let %59: i32 = add %58: i32, 2
  let %60: i32 = rem %59: i32, 2
  let %61: i32 = ne %60: i32, 0
  let %62: () = store %61: i32, %short_val.addr.3: i32*
  jmp label %short.end.3
%short.end.3:
  let %63: i32 = load %short_val.addr.3: i32*
  let %64: () = store %63: i32, %short_val.addr.2: i32*
  jmp label %short.end.2
%if_then.1:
  let %68: () = store 4, %result: i32*
  let %69: i32 = load %result: i32*
  let %70: () = call @putint, %69: i32
  jmp label %if_end.1
%if_end.1:
  let %71: () = store 0, %ret_val.addr: i32*
  jmp label %exit
%after_return:
  jmp label %exit
%exit:
  let %74: i32 = load %ret_val.addr: i32*
  ret %74: i32
}

