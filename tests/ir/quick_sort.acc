fn @putint(#x: i32) -> ();

fn @putch(#x: i32) -> ();

fn @putarray(#n: i32, #arr: i32*) -> ();

fn @getint() -> i32;

fn @getch() -> i32;

fn @getarray(#n: i32, #arr: i32*) -> ();

fn @Swap(#a: i32*, #l: i32, #h: i32) -> i32 {
%entry:
  let %l.addr: i32* = alloca i32, 1
  let %3: () = store #l: i32, %l.addr: i32*
  let %h.addr: i32* = alloca i32, 1
  let %5: () = store #h: i32, %h.addr: i32*
  let %ret_val.addr: i32* = alloca i32, 1
  let %temp: i32* = alloca i32, 1
  let %8: i32 = load %l.addr: i32*
  let %9: i32* = offset i32, #a: i32*, [%8: i32 < none]
  let %10: i32 = load %9: i32*
  let %11: () = store %10: i32, %temp: i32*
  let %12: i32 = load %h.addr: i32*
  let %13: i32* = offset i32, #a: i32*, [%12: i32 < none]
  let %14: i32 = load %13: i32*
  let %15: i32 = load %l.addr: i32*
  let %16: i32* = offset i32, #a: i32*, [%15: i32 < none]
  let %17: () = store %14: i32, %16: i32*
  let %18: i32 = load %temp: i32*
  let %19: i32 = load %h.addr: i32*
  let %20: i32* = offset i32, #a: i32*, [%19: i32 < none]
  let %21: () = store %18: i32, %20: i32*
  let %22: () = store 0, %ret_val.addr: i32*
  jmp label %exit
%after_return:
  jmp label %exit
%exit:
  let %25: i32 = load %ret_val.addr: i32*
  ret %25: i32
}

fn @Partition(#b: i32*, #low: i32, #high: i32) -> i32 {
%entry:
  let %low.addr: i32* = alloca i32, 1
  let %3: () = store #low: i32, %low.addr: i32*
  let %high.addr: i32* = alloca i32, 1
  let %5: () = store #high: i32, %high.addr: i32*
  let %ret_val.addr: i32* = alloca i32, 1
  let %base: i32* = alloca i32, 1
  let %8: i32 = load %low.addr: i32*
  let %9: i32* = offset i32, #b: i32*, [%8: i32 < none]
  let %10: i32 = load %9: i32*
  let %11: () = store %10: i32, %base: i32*
  jmp label %while_cond
%while_cond:
  let %15: i32 = load %low.addr: i32*
  let %16: i32 = load %high.addr: i32*
  let %17: i32 = lt %15: i32, %16: i32
  br %17: i32, label %while_body, label %while_end
%while_body:
  jmp label %while_cond.1
%while_end:
  let %64: i32 = load %low.addr: i32*
  let %65: () = store %64: i32, %ret_val.addr: i32*
  jmp label %exit
%while_cond.1:
  let %21: i32 = load %low.addr: i32*
  let %22: i32 = load %high.addr: i32*
  let %23: i32 = lt %21: i32, %22: i32
  let %short_val.addr: i32* = alloca i32, 1
  let %25: () = store %23: i32, %short_val.addr: i32*
  br %23: i32, label %short.rhs, label %short.end
%while_body.1:
  let %35: i32 = load %high.addr: i32*
  let %36: i32 = sub %35: i32, 1
  let %37: () = store %36: i32, %high.addr: i32*
  jmp label %while_cond.1
%while_end.1:
  let %38: i32 = load %low.addr: i32*
  let %39: i32 = load %high.addr: i32*
  let %40: i32 = call @Swap, #b: i32*, %38: i32, %39: i32
  jmp label %while_cond.2
%short.rhs:
  let %28: i32 = load %high.addr: i32*
  let %29: i32* = offset i32, #b: i32*, [%28: i32 < none]
  let %30: i32 = load %29: i32*
  let %31: i32 = load %base: i32*
  let %32: i32 = ge %30: i32, %31: i32
  let %33: () = store %32: i32, %short_val.addr: i32*
  jmp label %short.end
%short.end:
  let %34: i32 = load %short_val.addr: i32*
  br %34: i32, label %while_body.1, label %while_end.1
%while_cond.2:
  let %44: i32 = load %low.addr: i32*
  let %45: i32 = load %high.addr: i32*
  let %46: i32 = lt %44: i32, %45: i32
  let %short_val.addr.1: i32* = alloca i32, 1
  let %48: () = store %46: i32, %short_val.addr.1: i32*
  br %46: i32, label %short.rhs.1, label %short.end.1
%while_body.2:
  let %58: i32 = load %low.addr: i32*
  let %59: i32 = add %58: i32, 1
  let %60: () = store %59: i32, %low.addr: i32*
  jmp label %while_cond.2
%while_end.2:
  let %61: i32 = load %low.addr: i32*
  let %62: i32 = load %high.addr: i32*
  let %63: i32 = call @Swap, #b: i32*, %61: i32, %62: i32
  jmp label %while_cond
%short.rhs.1:
  let %51: i32 = load %low.addr: i32*
  let %52: i32* = offset i32, #b: i32*, [%51: i32 < none]
  let %53: i32 = load %52: i32*
  let %54: i32 = load %base: i32*
  let %55: i32 = le %53: i32, %54: i32
  let %56: () = store %55: i32, %short_val.addr.1: i32*
  jmp label %short.end.1
%short.end.1:
  let %57: i32 = load %short_val.addr.1: i32*
  br %57: i32, label %while_body.2, label %while_end.2
%after_return:
  jmp label %exit
%exit:
  let %68: i32 = load %ret_val.addr: i32*
  ret %68: i32
}

fn @QuickSort(#c: i32*, #low1: i32, #high1: i32) -> i32 {
%entry:
  let %low1.addr: i32* = alloca i32, 1
  let %3: () = store #low1: i32, %low1.addr: i32*
  let %high1.addr: i32* = alloca i32, 1
  let %5: () = store #high1: i32, %high1.addr: i32*
  let %ret_val.addr: i32* = alloca i32, 1
  let %7: i32 = load %low1.addr: i32*
  let %8: i32 = load %high1.addr: i32*
  let %9: i32 = lt %7: i32, %8: i32
  br %9: i32, label %if_then, label %if_end
%if_then:
  let %base1: i32* = alloca i32, 1
  let %13: i32 = load %low1.addr: i32*
  let %14: i32 = load %high1.addr: i32*
  let %15: i32 = call @Partition, #c: i32*, %13: i32, %14: i32
  let %16: () = store %15: i32, %base1: i32*
  let %17: i32 = load %low1.addr: i32*
  let %18: i32 = load %base1: i32*
  let %19: i32 = sub %18: i32, 1
  let %20: i32 = call @QuickSort, #c: i32*, %17: i32, %19: i32
  let %21: i32 = load %base1: i32*
  let %22: i32 = add %21: i32, 1
  let %23: i32 = load %high1.addr: i32*
  let %24: i32 = call @QuickSort, #c: i32*, %22: i32, %23: i32
  jmp label %if_end
%if_end:
  let %25: () = store 0, %ret_val.addr: i32*
  jmp label %exit
%after_return:
  jmp label %exit
%exit:
  let %28: i32 = load %ret_val.addr: i32*
  ret %28: i32
}

fn @main() -> i32 {
%entry:
  let %ret_val.addr: i32* = alloca i32, 1
  let %n: i32* = alloca i32, 1
  let %4: () = store 8, %n: i32*
  let %arr: i32* = alloca i32, 8
  let %i: i32* = alloca i32, 1
  let %7: () = store 0, %i: i32*
  jmp label %while_cond
%while_cond:
  let %11: i32 = load %i: i32*
  let %12: i32 = load %n: i32*
  let %13: i32 = lt %11: i32, %12: i32
  br %13: i32, label %while_body, label %while_end
%while_body:
  let %14: i32 = call @getint
  let %15: i32 = load %i: i32*
  let %16: i32* = offset i32, %arr: i32*, [%15: i32 < 8]
  let %17: () = store %14: i32, %16: i32*
  let %18: i32 = load %i: i32*
  let %19: i32 = add %18: i32, 1
  let %20: () = store %19: i32, %i: i32*
  jmp label %while_cond
%while_end:
  let %21: i32 = load %n: i32*
  let %22: i32 = sub %21: i32, 1
  let %23: i32 = call @QuickSort, %arr: i32*, 0, %22: i32
  let %24: () = store 0, %i: i32*
  jmp label %while_cond.1
%while_cond.1:
  let %28: i32 = load %i: i32*
  let %29: i32 = load %n: i32*
  let %30: i32 = lt %28: i32, %29: i32
  br %30: i32, label %while_body.1, label %while_end.1
%while_body.1:
  let %31: i32 = load %i: i32*
  let %32: i32* = offset i32, %arr: i32*, [%31: i32 < 8]
  let %33: i32 = load %32: i32*
  let %34: () = call @putint, %33: i32
  let %35: () = call @putch, 32
  let %36: i32 = load %i: i32*
  let %37: i32 = add %36: i32, 1
  let %38: () = store %37: i32, %i: i32*
  jmp label %while_cond.1
%while_end.1:
  let %39: () = store 0, %ret_val.addr: i32*
  jmp label %exit
%after_return:
  jmp label %exit
%exit:
  let %42: i32 = load %ret_val.addr: i32*
  ret %42: i32
}

